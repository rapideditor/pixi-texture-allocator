{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import { Matrix, Point, SCALE_MODES, Texture } from '@pixi/core';\nimport { Graphics, LINE_CAP, LINE_JOIN } from '@pixi/graphics';\n\n/** Define the dash: [dash length, gap size, dash size, gap size, ...] */\nexport type Dashes = number[];\n\nexport interface DashLineOptions {\n  dash?: Dashes;\n  width?: number;\n  color?: number;\n  alpha?: number;\n  scale?: number;\n  useTexture?: boolean;\n  useDots?: boolean;\n  cap?: LINE_CAP;\n  join?: LINE_JOIN;\n  alignment?: number;\n}\n\nconst dashLineOptionsDefault: Partial<DashLineOptions> = {\n  dash: [10, 5],\n  width: 1,\n  color: 0xffffff,\n  alpha: 1,\n  scale: 1,\n  useTexture: false,\n  alignment: 0.5\n};\n\n\nexport class DashLine {\n  graphics: Graphics;\n\n  /** current length of the line */\n  lineLength: number;\n\n  /** cursor location */\n  cursor = new Point();\n\n  /** desired scale of line */\n  scale = 1;\n\n  // sanity check to ensure the lineStyle is still in use\n  private activeTexture: Texture;\n\n  private start: Point;\n\n  private dashSize: number;\n  private dash: number[];\n\n  private useTexture: boolean;\n  private options: DashLineOptions;\n\n  // cache of Textures for dashed lines\n  static dashTextureCache: Record<string, Texture> = {};\n\n  /**\n   * Create a DashLine\n   * @param graphics\n   * @param [options]\n   * @param [options.useTexture=false] - use the texture based render (useful for very large or very small dashed lines)\n   * @param [options.dash=[10,5] - an array holding the dash and gap (eg, [10, 5, 20, 5, ...])\n   * @param [options.width=1] - width of the dashed line\n   * @param [options.alpha=1] - alpha of the dashed line\n   * @param [options.color=0xffffff] - color of the dashed line\n   * @param [options.cap] - add a LINE_CAP style to dashed lines (only works for useTexture: false)\n   * @param [options.join] - add a LINE_JOIN style to the dashed lines (only works for useTexture: false)\n   * @param [options.alignment] - The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner)\n   */\n  constructor(graphics: Graphics, options: DashLineOptions = {}) {\n    this.graphics = graphics;\n    options = { ...dashLineOptionsDefault, ...options };\n    this.dash = options.dash;\n    this.dashSize = this.dash.reduce((a, b) => a + b);\n    this.useTexture = options.useTexture;\n    this.options = options;\n    this.setLineStyle();\n  }\n\n  /** resets line style to enable dashed line (useful if lineStyle was changed on graphics element) */\n  setLineStyle() {\n    const options = this.options;\n    if (this.useTexture) {\n      const texture = DashLine.getTexture(options, this.dashSize);\n      this.graphics.lineTextureStyle({\n        width: options.width * options.scale,\n        color: options.color,\n        alpha: options.alpha,\n        texture,\n        alignment: options.alignment\n      });\n      this.activeTexture = texture;\n    } else {\n      this.graphics.lineStyle({\n        width: options.width * options.scale,\n        color: options.color,\n        alpha: options.alpha,\n        cap: options.cap,\n        join: options.join,\n        alignment: options.alignment\n      });\n    }\n    this.scale = options.scale;\n  }\n\n  private static distance(x0: number, y0: number, x1: number, y1: number): number {\n    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n  }\n\n\n  moveTo(x: number, y: number): this {\n    this.lineLength = 0;\n    this.cursor.set(x, y);\n    this.start = new Point(x, y);\n    this.graphics.moveTo(this.cursor.x, this.cursor.y);\n    return this;\n  }\n\n\n  lineTo(x: number, y: number, closePath?: boolean): this {\n    if (typeof this.lineLength === undefined) {\n      this.moveTo(0, 0);\n    }\n    let [x0, y0] = [this.cursor.x, this.cursor.y];   // the position of the cursor\n    const length = DashLine.distance(x0, y0, x, y);\n    if (length < 1) return this;   // dont bother advancing the cursor less than a pixel\n\n    const angle = Math.atan2(y - y0, x - x0);\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const closed = closePath && x === this.start.x && y === this.start.y;\n\n    if (this.useTexture) {\n      this.graphics.moveTo(x0, y0);\n      this.adjustLineStyle(angle);\n      if (closed && this.dash.length % 2 === 0) {\n        const gap = Math.min(this.dash[this.dash.length - 1], length);\n        this.graphics.lineTo(x - cos * gap, y - sin * gap);\n        this.graphics.closePath();\n      } else {\n        this.graphics.lineTo(x, y);\n      }\n\n    } else {\n      this.setLineStyle();  // Not sure why this fixes #2?\n\n      // Determine where in the dash pattern the cursor is starting from.\n      const origin = this.lineLength % (this.dashSize * this.scale);\n      let dashIndex: number = 0;  // which dash in the pattern\n      let dashStart: number = 0;  // how far in the dash\n      let dashX = 0;\n      for (let i = 0; i < this.dash.length; i++) {\n        const dashSize = this.dash[i] * this.scale;\n        if (origin < dashX + dashSize) {\n          dashIndex = i;\n          dashStart = origin - dashX;\n          break;\n        } else {\n          dashX += dashSize;\n        }\n      }\n\n      // Advance the line\n      let remaining = length;\n      while (remaining > 1) {   // stop if we are within 1 pixel\n        const dashSize = (this.dash[dashIndex] * this.scale) - dashStart;\n        let dist = (remaining > dashSize) ? dashSize : remaining;\n\n        if (closed) {\n          const remainingDistance = DashLine.distance(x0 + cos * dist, y0 + sin * dist, this.start.x, this.start.y);\n          if (remainingDistance <= dist) {\n            if (dashIndex % 2 === 0) {\n              const lastDash = DashLine.distance(x0, y0, this.start.x, this.start.y) - this.dash[this.dash.length - 1] * this.scale;\n              x0 += cos * lastDash;\n              y0 += sin * lastDash;\n              this.graphics.lineTo(x0, y0);\n              this.lineLength += lastDash;\n              this.cursor.set(x0, y0);\n            }\n            break;\n          }\n        }\n\n        x0 += cos * dist;\n        y0 += sin * dist;\n        if (dashIndex % 2) {  // odd dashIndex = 'on', even dashIndex = 'off'\n          this.graphics.moveTo(x0, y0);\n        } else {\n          this.graphics.lineTo(x0, y0);\n        }\n        this.lineLength += dist;\n        this.cursor.set(x0, y0);\n        remaining -= dist;\n\n        // Prepare for next dash (only really matters if there is remaining length)\n        dashIndex++;\n        dashIndex = dashIndex === this.dash.length ? 0 : dashIndex;\n        dashStart = 0;\n      }\n    }\n\n    return this;\n  }\n\n\n  closePath() {\n    this.lineTo(this.start.x, this.start.y, true);\n  }\n\n\n  drawCircle(x: number, y: number, radius: number, points = 80, matrix?: Matrix): this {\n    const interval = (Math.PI * 2) / points;\n    let angle = 0;\n    let first = new Point(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);\n    if (matrix) {\n      matrix.apply(first, first);\n      this.moveTo(first[0], first[1]);\n    } else {\n      this.moveTo(first.x, first.y);\n    }\n    angle += interval;\n    for (let i = 1; i < points + 1; i++) {\n      const next = (i === points) ? [first.x, first.y] : [x + Math.cos(angle) * radius, y + Math.sin(angle) * radius];\n      this.lineTo(next[0], next[1]);\n      angle += interval;\n    }\n    return this;\n  }\n\n\n  drawEllipse(x: number, y: number, radiusX: number, radiusY: number, points = 80, matrix?: Matrix ): this {\n    const interval = (Math.PI * 2) / points;\n    let first: { x: number; y: number };\n    const point = new Point();\n    let f = 0;\n    for (let i = 0; i < Math.PI * 2; i += interval) {\n      let x0 = x - radiusX * Math.sin(i);\n      let y0 = y - radiusY * Math.cos(i);\n      if (matrix) {\n        point.set(x0, y0);\n        matrix.apply(point, point);\n        x0 = point.x;\n        y0 = point.y;\n      }\n      if (i === 0) {\n        this.moveTo(x0, y0);\n        first = { x: x0, y: y0 };\n      } else {\n        this.lineTo(x0, y0);\n      }\n    }\n    this.lineTo(first.x, first.y, true);\n    return this;\n  }\n\n\n  drawPolygon(points: Point[] | number[], matrix?: Matrix): this {\n    const p = new Point();\n    if (typeof points[0] === 'number') {\n      if (matrix) {\n        p.set(points[0] as number, points[1] as number);\n        matrix.apply(p, p);\n        this.moveTo(p.x, p.y);\n        for (let i = 2; i < points.length; i += 2) {\n          p.set(points[i] as number, points[i + 1] as number);\n          matrix.apply(p, p);\n          this.lineTo(p.x, p.y, i === points.length - 2);\n        }\n      } else {\n        this.moveTo(points[0] as number, points[1] as number);\n        for (let i = 2; i < points.length; i += 2) {\n          this.lineTo(points[i] as number, points[i + 1] as number, i === points.length - 2);\n        }\n      }\n    } else {\n      if (matrix) {\n        const point = points[0] as Point;\n        p.copyFrom(point);\n        matrix.apply(p, p);\n        this.moveTo(p.x, p.y);\n        for (let i = 1; i < points.length; i++) {\n          const point = points[i] as Point;\n          p.copyFrom(point);\n          matrix.apply(p, p);\n          this.lineTo(p.x, p.y, i === points.length - 1);\n        }\n      } else {\n        const point = points[0] as Point;\n        this.moveTo(point.x, point.y);\n        for (let i = 1; i < points.length; i++) {\n          const point = points[i] as Point;\n          this.lineTo(point.x, point.y, i === points.length - 1);\n        }\n      }\n    }\n    return this;\n  }\n\n\n  drawRect(x: number, y: number, width: number, height: number, matrix?: Matrix): this {\n    if (matrix) {\n      const p = new Point();\n\n      // moveTo(x, y)\n      p.set(x, y);\n      matrix.apply(p, p);\n      this.moveTo(p.x, p.y);\n\n      // lineTo(x + width, y)\n      p.set(x + width, y);\n      matrix.apply(p, p);\n      this.lineTo(p.x, p.y);\n\n      // lineTo(x + width, y + height)\n      p.set(x + width, y + height);\n      matrix.apply(p, p);\n      this.lineTo(p.x, p.y);\n\n      // lineto(x, y + height)\n      p.set(x, y + height);\n      matrix.apply(p, p);\n      this.lineTo(p.x, p.y);\n\n      // lineTo(x, y, true)\n      p.set(x, y);\n      matrix.apply(p, p);\n      this.lineTo(p.x, p.y, true);\n    } else {\n      this.moveTo(x, y)\n        .lineTo(x + width, y)\n        .lineTo(x + width, y + height)\n        .lineTo(x, y + height)\n        .lineTo(x, y, true);\n    }\n    return this;\n  }\n\n\n  // adjust the matrix for the dashed texture\n  private adjustLineStyle(angle: number) {\n    const lineStyle = this.graphics.line;\n    lineStyle.matrix = new Matrix();\n    if (angle) {\n      lineStyle.matrix.rotate(angle);\n    }\n    if (this.scale !== 1) lineStyle.matrix.scale(this.scale, this.scale);\n    const textureStart = -this.lineLength;\n    lineStyle.matrix.translate(\n      this.cursor.x + textureStart * Math.cos(angle),\n      this.cursor.y + textureStart * Math.sin(angle)\n    );\n    this.graphics.lineStyle(lineStyle);\n  }\n\n\n  // creates or uses cached texture\n  private static getTexture(options: DashLineOptions, dashSize: number): Texture {\n    const key = options.dash.toString();\n    if (DashLine.dashTextureCache[key]) {\n      return DashLine.dashTextureCache[key];\n    }\n    const canvas = document.createElement('canvas');\n    canvas.width = dashSize;\n    canvas.height = Math.ceil(options.width);\n    const context = canvas.getContext('2d');\n    if (!context) {\n      console.warn('Did not get context from canvas');\n      return null;\n    }\n    context.strokeStyle = 'white';\n    context.globalAlpha = options.alpha;\n    context.lineWidth = options.width;\n    let x = 0;\n    const y = options.width / 2;\n    context.moveTo(x, y);\n    for (let i = 0; i < options.dash.length; i += 2) {\n      x += options.dash[i];\n      context.lineTo(x, y);\n      if (options.dash.length !== i + 1) {\n        x += options.dash[i + 1];\n        context.moveTo(x, y);\n      }\n    }\n    context.stroke();\n    const texture = (DashLine.dashTextureCache[key] = Texture.from(canvas));\n    texture.baseTexture.scaleMode = SCALE_MODES.NEAREST;\n    return texture;\n  }\n}\n"],
  "mappings": "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",
  "names": ["point"]
}
