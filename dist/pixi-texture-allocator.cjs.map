{
  "version": 3,
  "sources": ["../src/index.ts", "../src/AtlasSource.ts", "../src/TextureAllocator.ts", "../src/GuilloteneAllocator.ts", "../src/Area.ts", "../src/AtlasAllocator.ts", "../src/CanvasTextureAllocator.ts", "../src/RenderTextureAllocator.ts"],
  "sourcesContent": ["export * from './AtlasAllocator';\nexport * from './AtlasSource';\nexport * from './CanvasTextureAllocator';\nexport * from './GuilloteneAllocator';\nexport * from './RenderTextureAllocator';\nexport * from './TextureAllocator';\nexport * from './TextureSlab';", "import { RendererType, TextureSource } from 'pixi.js';\n\nimport type { GlTexture, GlRenderingContext, GLTextureUploader, GpuTextureUploader, GPU, Rectangle, Renderer, Texture } from 'pixi.js';\n\n/**\n * Types of image sources supported by {@link AtlasSource}.\n *\n * @public\n */\nexport type AtlasItemSource = HTMLImageElement | HTMLCanvasElement | ImageBitmap | ImageData | ArrayBufferView;\n\n/**\n * An item that is uploaded to the atlas texture.\n *\n * @public\n */\nexport type AtlasItem =\n{\n    /**\n     * The location of the atlas item in the base-texture's space.\n     */\n    frame: Rectangle;\n\n    /**\n     * The source of the texture data.\n     */\n    source: AtlasItemSource;\n\n    /**\n     * This flags when the resource is to be re-uploaded.\n     */\n    dirtyId: number;\n\n    /**\n     * This flags when the resource is uploaded and update-to-date with the dirty ID.\n     */\n    updateId: number;\n\n    /**\n     * The texture holding this item.\n     */\n    texture: Texture;\n};\n\n/**\n * An {@code AtlasSource} is used by {@link AtlasAllocator} to manage texture sources.\n *\n * @public\n */\nexport class AtlasSource extends TextureSource\n{\n    /**\n     * The list of managed texture sources in the atlas.\n     */\n    public managedItems: AtlasItem[];\n\n    public uploadMethodId = 'atlas';\n\n    /**\n     * Creates an atlas resource.\n     *\n     * @param width\n     * @param height\n     */\n    constructor(width: number, height: number)\n    {\n        super({\n            width,\n            height,\n        });\n\n        this.managedItems = [];\n    }\n}\n\nlet didWarnUnsupportedAtlasSource = false;\n\nconst glUploadAtlasResource = {\n    id: 'atlas',\n    upload(source: AtlasSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number): void\n    {\n        const { width, height } = source;\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);\n\n        // Allocate the texture on the GPU\n        if (glTexture.width !== width || glTexture.height !== height)\n        {\n            glTexture.width = width;\n            glTexture.height = height;\n\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.format,\n                width,\n                height,\n                0,\n                glTexture.format,\n                glTexture.type,\n                undefined,\n            );\n        }\n\n        const items = source.managedItems;\n\n        // Upload all atlas items.\n        for (let i = 0, j = items.length; i < j; i++)\n        {\n            const item = items[i];\n\n            // see https://github.com/rapideditor/pixi-texture-allocator/issues/2\n            // if (item.updateId === item.dirtyId)\n            // {\n            //     continue;\n            // }\n\n            const frame = item.frame;\n            let itemSource = item.source;\n\n            if (webGLVersion === 1)\n            {\n                if (itemSource instanceof ImageData)\n                {\n                    itemSource = itemSource.data; // pass the typed array directly\n                }\n                else if (itemSource instanceof HTMLCanvasElement)\n                {\n                    const ctx = itemSource.getContext('2d');\n                    const [w, h] = [itemSource.width, itemSource.height];\n\n                    itemSource = ctx.getImageData(0, 0, w, h).data;\n                }\n                else if (itemSource instanceof HTMLImageElement)\n                {\n                    const [w, h] = [itemSource.naturalWidth, itemSource.naturalHeight];\n                    const canvas = document.createElement('canvas');\n\n                    canvas.width = w;\n                    canvas.height = h;\n\n                    const ctx = canvas.getContext('2d');\n\n                    ctx.drawImage(itemSource, 0, 0);\n                    itemSource = ctx.getImageData(0, 0, w, h).data;\n                }\n                else\n                if (!didWarnUnsupportedAtlasSource)\n                {\n                    console.warn('Unsupported atlas source type. Failed to upload on WebGL 1', itemSource);\n                    didWarnUnsupportedAtlasSource = true;\n                }\n            }\n\n            gl.texSubImage2D(\n                glTexture.target,\n                0,\n                frame.x,\n                frame.y,\n                frame.width,\n                frame.height,\n                glTexture.format,\n                glTexture.type,\n                itemSource as any,\n            );\n\n            item.updateId = item.dirtyId;\n        }\n    },\n} satisfies GLTextureUploader;\n\nconst gpuUploadAtlasResource = {\n    type: 'atlas',\n    upload(source: AtlasSource, gpuTexture: GPUTexture, gpu: GPU): void\n    {\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        for (const item of source.managedItems)\n        {\n            // see https://github.com/rapideditor/pixi-texture-allocator/issues/2\n            // if (item.updateId === item.dirtyId)\n            // {\n            //     continue;\n            // }\n\n            gpu.device.queue.copyExternalImageToTexture(\n                { source: item.source },\n                {\n                    texture: gpuTexture, premultipliedAlpha,\n                    origin: {\n                        x: item.frame.x,\n                        y: item.frame.y,\n                    },\n                },\n                {\n                    height: item.frame.height,\n                    width: item.frame.width,\n                },\n            );\n        }\n    },\n} satisfies GpuTextureUploader<AtlasSource>;\n\n/**\n * Registers the optimized atlas texture uploader for use in WebGL.\n *\n * @param renderer\n * @public\n */\nexport function optimizeAtlasUploads(renderer: Renderer): void\n{\n    if (renderer.type === RendererType.WEBGL)\n    {\n        // eslint-disable-next-line dot-notation\n        renderer.texture['_uploads'].atlas = glUploadAtlasResource;\n    }\n    else\n    {\n        // eslint-disable-next-line dot-notation\n        renderer.texture['_uploads'].atlas = gpuUploadAtlasResource;\n    }\n}", "import { Rectangle, Texture, TextureSource } from 'pixi.js';\nimport { GuilloteneAllocator } from './GuilloteneAllocator';\n\nimport type { TextureSlab } from './TextureSlab';\n\nconst tempRect = new Rectangle();\n\nfunction padded(val: number, padding: number): number\n{\n    return val + (2 * padding);\n}\n\n/**\n * The texture allocator dynamically manages space on base-texture slabs. It can be used to generate\n * atlases on demand, which improve batching efficiency.\n *\n * @public\n */\nexport abstract class TextureAllocator<S extends TextureSource, T extends Texture = Texture>\n{\n    /**\n     * The width of texture slabs.\n     */\n    public readonly slabWidth: number;\n\n    /**\n     * The height of texture slabs.\n     */\n    public readonly slabHeight: number;\n\n    /**\n     * The list of base-textures that are used to allocate texture space.\n     */\n    protected textureSlabs: TextureSlab<S>[];\n\n    /**\n     * @param slabWidth - The width of base-texture slabs. This should be at most 2048.\n     * @param slabHeight - The height of base-texture slabs. This should be at most 2048.\n     */\n    constructor(slabWidth = 2048, slabHeight = 2048)\n    {\n        this.slabWidth = slabWidth;\n        this.slabHeight = slabHeight;\n\n        this.textureSlabs = [];\n    }\n\n    get maxWidth(): number\n    {\n        return this.slabWidth - (2 * this.calculatePadding(this.slabWidth, this.slabHeight));\n    }\n\n    get maxHeight(): number\n    {\n        return this.slabHeight - (2 * this.calculatePadding(this.slabWidth, this.slabHeight));\n    }\n\n    /**\n     * Allocates a texture from this allocator.\n     *\n     * If its existing slab pool has enough space, the texture is issued from one. Otherwise,\n     * a new slab is created and the texture is issued from it. However, if the requested\n     * dimensions are larger than slabs themselves, then `null` is always returned.\n     *\n     * To upload a texture source, you will have to create an atlas-managing {@link TextureSource}\n     * yourself on the base-texture. The {@link AtlasAllocator} does this for you, while the\n     * {@link CanvasTextureAllocator} can be used to draw on a canvas-based atlas.\n     *\n     * @param width - The width of the requested texture.\n     * @param height - The height of the requested texture.\n     * @param padding - The padding requested around the texture, to prevent bleeding.\n     * @return The allocated texture, if successful; otherwise, `null`.\n     */\n    allocate(width: number, height: number, padding = this.calculatePadding(width, height)): T\n    {\n        // Cannot allocate a texture larger than a texture-slab.\n        if (padded(width, padding) > this.slabWidth\n                || padded(height, padding) > this.slabHeight)\n        {\n            return null;\n        }\n\n        const slabs = this.textureSlabs;\n\n        // Loop through the slabs and find one with enough space, if any.\n        for (let i = 0, j = slabs.length; i < j; i++)\n        {\n            const slab = slabs[i];\n            const texture = this.issueTexture(slab, width, height, padding);\n\n            if (texture)\n            {\n                return texture;\n            }\n        }\n\n        // Issue a new slab.\n        const slab = this.createSlab();\n\n        // Append this slab to the head of the list.\n        this.textureSlabs.unshift(slab);\n\n        // Issue the texture from this blank slab.\n        return this.issueTexture(slab, width, height, padding);\n    }\n\n    /**\n     * Frees the texture and reclaims its space. It is assumed you will not use it again, and have\n     * destroyed any resource uploading its data.\n     *\n     * @param texture\n     * @throws When the texture was not located in this allocator.\n     */\n    free(texture: T): void\n    {\n        const slab = this.textureSlabs.find((sl) => sl.slab === texture.source);\n\n        if (!slab)\n        {\n            throw new Error('The texture cannot be freed because '\n                + 'its base-texture is not pooled by this allocator. '\n                + 'This is either a bug in TextureAllocator or you tried to free a '\n                + 'texture that was never allocated by one.');\n        }\n\n        const textureEntry = slab.managedTextures.find((entry) => entry.texture === texture);\n\n        if (!textureEntry)\n        {\n            throw new Error('The texture cannot be freed because it was not found '\n                + 'in the managed list of issued textures on its slab. This may be because you '\n                + 'duplicated this texture or a bug in TextureAllocator');\n        }\n\n        slab.managedArea.free(textureEntry.area);\n        slab.managedTextures.splice(slab.managedTextures.indexOf(textureEntry), 1);\n    }\n\n    protected calculatePadding(width: number, height: number): number\n    {\n        const dimen = Math.max(width, height);\n\n        if (dimen < 64)\n        {\n            return 2;\n        }\n        else if (dimen < 128)\n        {\n            return 4;\n        }\n        else if (dimen < 1024)\n        {\n            return 8;\n        }\n\n        return 16;\n    }\n\n    /**\n     * Creates a texture slab. Uses {@link this.createSlabSource} to initialize the texture data.\n     */\n    protected createSlab(): TextureSlab<S>\n    {\n        return {\n            managedArea: new GuilloteneAllocator(this.slabWidth, this.slabHeight),\n            managedTextures: [],\n            slab: this.createSlabSource(),\n        };\n    }\n\n    /**\n     * Creates a new texture source to initialize a texture slab.\n     */\n    protected abstract createSlabSource(): S;\n\n    /**\n     * Creates a texture on the given base-texture at {@code frame}.\n     *\n     * @param source - The atlas source that will hold the texture's space.\n     * @param frame - The frame in which the texture will be stored.\n     */\n    protected createTexture(source: S, frame: Rectangle): T\n    {\n        // Override this method to return correct texture type T.\n        return new Texture({ source, frame }) as unknown as T;\n    }\n\n    /**\n     * Issues a texture from the given texture slab, if possible.\n     *\n     * @param slab - The texture slab to allocate frame.\n     * @param width - The width of the requested texture.\n     * @param height - The height of the requested texture.\n     * @param padding - Padding required around the texture.\n     * @return The issued texture, if successful; otherwise, `null`.\n     */\n    protected issueTexture(slab: TextureSlab<S>, width: number, height: number, padding = 0): T\n    {\n        const area = slab.managedArea.allocate(width + 2 * padding, height + 2 * padding);\n\n        if (!area)\n        {\n            return null;\n        }\n\n        tempRect.copyFrom(area);\n        tempRect.pad(-padding);\n\n        const issuedTexture = this.createTexture(slab.slab, tempRect.clone());\n\n        slab.managedTextures.push({\n            area,\n            texture: issuedTexture,\n        });\n\n        return issuedTexture;\n    }\n}", "import { Rectangle } from 'pixi.js';\nimport { Area, AreaOrientation } from './Area';\n\nimport type { AreaAllocator } from './AreaAllocator';\nimport type { AreaField } from './Area';\n\n/**\n * An allocator node is represented as a tuple. The zeroth element is the parent of the node. The first element\n * always exists and is the texture area it wholly represents. The second element is whether the rectangle\n * is allocated or free. The last element is optional and is the list\n * of its children.\n *\n * @public\n * @ignore\n */\nexport type AreaNode = [AreaNode, AreaField, boolean] | [AreaNode, AreaField, AreaNode[]];\n\n/**\n * Pointer to guillotene node.\n *\n * @public\n * @ignore\n */\nexport type AreaPtr = { __mem_area: AreaNode };\n\n/**\n * @public\n * @ignore\n */\nexport enum SPLIT_ORIENTATION {\n    HOR = 0,\n    VERT = 1,\n    NONE = 2\n}\n\nconst tempRect = new Rectangle();\n\n/** @public */\nexport class GuilloteneAllocator implements AreaAllocator<AreaPtr>\n{\n    protected _root: AreaNode;\n\n    private _width: number;\n    private _height: number;\n\n    constructor(width: number, height: number)\n    {\n        this._width = width;\n        this._height = height;\n\n        // NOTE: getFrame assumes root node is always horizontal!\n        this._root = [\n            null,\n            Area.makeArea(0, this._height, AreaOrientation.HORIZONTAL),\n            false\n        ];\n    }\n\n    /**\n     * Allocates an area of the given `width` and `height`.\n     *\n     * @param width - The width required for the allocated area.\n     * @param height - The height required for the allocated area.\n     * @param rect - An optional `Rectangle` instance to put the resulting area frame into.\n     * @return The rectangle frame of the area allocated.\n     */\n    allocate(width: number, height: number, rect?: Rectangle): Rectangle & AreaPtr\n    {\n        const area = this.findArea(width, height);\n\n        if (!area)\n        {\n            return null;\n        }\n\n        if (!rect)\n        {\n            rect = new Rectangle();\n        }\n\n        this.getFrame(area, rect);\n\n        const hole = new Rectangle(rect.x, rect.y, width, height);\n        const node = this.split(area, rect, hole);\n\n        rect.copyFrom(hole);\n        (rect as any).__mem_area = node;\n\n        return rect as (Rectangle & AreaPtr);\n    }\n\n    /**\n     * Frees the area represented by the given area pointer. The original rectangle returned by\n     * {@link GuilloteneAllocator#allocate} included this pointer (the `__mem_area` property).\n     *\n     * @param areaPtr\n     */\n    free(areaPtr: AreaPtr): void\n    {\n        const area = areaPtr.__mem_area;\n\n        area[2] = false;\n        this.merge(area);\n    }\n\n    get width(): number\n    {\n        return this._width;\n    }\n\n    get height(): number\n    {\n        return this._height;\n    }\n\n    /**\n     * Returns the [area]{@link Area} data for the node.\n     *\n     * @param node\n     * @returns The area data for the node.\n     */\n    protected getAreaField(node: AreaNode): AreaField\n    {\n        return node[1];\n    }\n\n    /**\n     * Returns the rectangle covered by the area node.\n     *\n     * @param node - The node whose covered rectangular area is needed.\n     * @param rect - An optional `Rectangle` instance to put the data in.\n     * @return The rectangle covered by `node`.\n     */\n    protected getFrame(node: AreaNode, rect?: Rectangle): Rectangle\n    {\n        if (!rect)\n        {\n            rect = new Rectangle();\n        }\n\n        const nodeArea = this.getAreaField(node);\n        const nodeParent = this.getParent(node);\n        const nodeOrientation = Area.getOrientation(nodeArea);\n        const nodeOpen = Area.getOpenOffset(nodeArea);\n        const nodeClose = Area.getCloseOffset(nodeArea);\n        const parentOpen = nodeParent ? Area.getOpenOffset(nodeParent[1]) : 0;\n        const parentClose = nodeParent ? Area.getCloseOffset(nodeParent[1]) : this._width;// (because root node is horizontal)\n\n        if (nodeOrientation) // VERTICAL\n        {\n            rect.x = nodeOpen;\n            rect.y = parentOpen;\n            rect.width = nodeClose - rect.x;\n            rect.height = parentClose - parentOpen;\n        }\n        else // HORIZONTAL\n        {\n            rect.x = parentOpen;\n            rect.y = nodeOpen;\n            rect.width = parentClose - rect.x;\n            rect.height = nodeClose - rect.y;\n        }\n\n        return rect;\n    }\n\n    /**\n     * Returns the parent of the area node.\n     *\n     * @param node\n     * @return The parent of `node`\n     */\n    protected getParent(node: AreaNode): AreaNode\n    {\n        return node[0];\n    }\n\n    /**\n     * Returns whether the given node has any children.\n     *\n     * @param node\n     * @return Whether the given node has any children.\n     */\n    protected hasChildren(node: AreaNode): boolean\n    {\n        return (Array.isArray(node[2]) && (node[2].length !== 0));\n    }\n\n    /**\n     * Returns the children of the passed node, if any.\n     *\n     * @param node\n     */\n    protected getChildren(node: AreaNode): AreaNode[]\n    {\n        if (!Array.isArray(node[2])) {\n            throw new Error(\"Children don't exist\")\n        }\n\n        return node[2];\n    }\n\n    protected addChild(parent: AreaNode, ...nodes: AreaNode[]): void\n    {\n        parent[2] = Array.isArray(parent[2]) ? parent[2] : []\n        parent[2].push(...nodes)\n    }\n\n    /**\n     * Finds an area node with minimum width `aw` and minimum height `ah`.\n     *\n     * @param aw\n     * @param ah\n     */\n    protected findArea(aw: number, ah: number): AreaNode\n    {\n        return this.findAreaRecursive(this._root, aw, ah);\n    }\n\n    /**\n     * The recursive implementation for {@link AreaAllocator#findArea}.\n     *\n     * @param rootArea\n     * @param aw\n     * @param ah\n     */\n    protected findAreaRecursive(rootArea: AreaNode, aw: number, ah: number): AreaNode\n    {\n        const frame = this.getFrame(rootArea, tempRect);\n\n        if (frame.width < aw || frame.height < ah)\n        {\n            return null;\n        }\n\n        if (!this.hasChildren(rootArea))\n        {\n            const dx = frame.width - aw;\n            const dy = frame.height - ah;\n\n            if (dx < 0 || dy < 0 || rootArea[2])\n            {\n                return null;\n            }\n\n            return rootArea;\n        }\n\n        const children = this.getChildren(rootArea);\n\n        let bestCandidate = null;\n        let bestCandidateScore = Infinity;\n\n        for (let i = 0, j = children.length; i < j; i++)\n        {\n            const candidate = this.findAreaRecursive(children[i], aw, ah);\n\n            if (!candidate)\n            {\n                continue;\n            }\n\n            const candidateFrame = this.getFrame(candidate, tempRect);\n\n            const dx = candidateFrame.width - aw;\n            const dy = candidateFrame.height - ah;\n\n            if (dx < 0 || dy < 0)\n            {\n                continue;\n            }\n            if (!dx && !dy)\n            {\n                // Perfect fit!\n                return candidate;\n            }\n\n            const score = Math.min(dx, dy);\n\n            if (bestCandidateScore > score)\n            {\n                bestCandidate = candidate;\n                bestCandidateScore = score;\n            }\n        }\n\n        return bestCandidate;\n    }\n\n    /**\n     * Returns the orientation of the primary split of host.\n     */\n    protected splitOrientation(host: Rectangle, hole: Rectangle): SPLIT_ORIENTATION\n    {\n        if (hole.width === host.width && hole.height === host.height) {\n            return SPLIT_ORIENTATION.NONE;\n        }\n        if (hole.width === host.width) {\n            return SPLIT_ORIENTATION.VERT;\n        }\n        if (hole.height === host.height) {\n            return SPLIT_ORIENTATION.HOR;\n        }\n\n        // ____________________\n        // |        |         |\n        // |        |         |\n        // |  hole  |         |\n        // |        |         |\n        // |________| Primary |\n        // |        |         |\n        // |        |         |\n        // |  Sec.  |         |\n        // |________|_________|\n        const horAreaDiff = Math.abs(\n            // (Primary) Right\n            (host.width - hole.width) * host.height -\n            // (Secondary) Bottom\n            hole.width * (host.height - hole.height)\n        )\n\n        // ____________________\n        // |        |         |\n        // |        |         |\n        // |  hole  | Sec.    |\n        // |        |         |\n        // |________|_________|\n        // |                  |\n        // |    Primary       |\n        // |__________________|\n        const verAreaDiff = Math.abs(\n            // (Primary) Bottom\n            host.width * (host.height - hole.height) -\n            (host.width - hole.width) * hole.height\n        )\n\n        if (horAreaDiff > verAreaDiff)\n        {\n            return SPLIT_ORIENTATION.HOR\n        }\n        else\n        {\n            return SPLIT_ORIENTATION.VERT\n        }\n    }\n\n    protected split(\n        area: AreaNode,\n        areaFrame: Rectangle,\n        holeFrame: Rectangle,\n        orientation: SPLIT_ORIENTATION = this.getParent(area) ? this.splitOrientation(areaFrame, holeFrame) : SPLIT_ORIENTATION.HOR\n    ): AreaNode\n    {\n        if (area[2] === true)\n        {\n            throw new Error('Cannot deallocate')\n        }\n        if (orientation === SPLIT_ORIENTATION.NONE)\n        {\n            area[2] = true;\n            return area;\n        }\n\n        return this[orientation === SPLIT_ORIENTATION.HOR\n            ? 'splitPrimaryHorizontal'\n            : 'splitPrimaryVertical'](area, areaFrame, holeFrame);\n    }\n\n    private splitPrimaryHorizontal(area: AreaNode, areaFrame: Rectangle, holeFrame: Rectangle): AreaNode\n    {\n        const field = this.getAreaField(area);\n        const axis = Area.getOrientation(field);\n        const parent = this.getParent(area);\n\n        if (this.hasChildren(area))\n        {\n            throw new Error(\"Can't split non-leaf node\")\n        }\n\n        const firstChild: AreaNode = [\n            area,\n            Area.makeArea(\n                areaFrame.left,\n                areaFrame.x + holeFrame.width,\n                AreaOrientation.VERTICAL\n            ),\n            []\n        ];\n        const secondChild: AreaNode = [\n            area,\n            Area.makeArea(\n                areaFrame.x + holeFrame.width,\n                areaFrame.right,\n                AreaOrientation.VERTICAL\n            ),\n            false\n        ];\n\n        if (axis === AreaOrientation.HORIZONTAL) {\n            this.addChild(area, firstChild, secondChild)\n        } else {\n            const i = this.getChildren(parent).indexOf(area);\n\n            firstChild[0] = parent;\n            secondChild[0] = parent;\n\n            this.getChildren(parent).splice(i, 1, firstChild, secondChild);\n        }\n\n        if (holeFrame.height !== areaFrame.height)\n        {\n            const secondaryFirstChild: AreaNode = [\n                firstChild,\n                Area.makeArea(\n                    areaFrame.top,\n                    areaFrame.y + holeFrame.height,\n                    AreaOrientation.HORIZONTAL\n                ),\n                true\n            ];\n            const secondarySecondChild: AreaNode = [\n                firstChild,\n                Area.makeArea(\n                    areaFrame.y + holeFrame.height,\n                    areaFrame.bottom,\n                    AreaOrientation.HORIZONTAL\n                ),\n                false\n            ];\n\n            this.addChild(firstChild, secondaryFirstChild, secondarySecondChild);\n\n            return secondaryFirstChild;\n        }\n        else\n        {\n            (firstChild as AreaNode)[2] = true;\n        }\n\n        return firstChild;\n    }\n\n    private splitPrimaryVertical(area: AreaNode, areaFrame: Rectangle, holeFrame: Rectangle): AreaNode\n    {\n        const field = this.getAreaField(area);\n        const axis = Area.getOrientation(field);\n        const parent = this.getParent(area);\n\n        if (this.hasChildren(area)) {\n            throw new Error(\"Can't split non-leaf node\")\n        }\n\n        const primaryFirstChild: AreaNode = [\n            area,\n            Area.makeArea(\n                areaFrame.top,\n                areaFrame.y + holeFrame.height,\n                AreaOrientation.HORIZONTAL\n            ),\n            []\n        ];\n        const primarySecondChild: AreaNode = [\n            area,\n            Area.makeArea(\n                areaFrame.y + holeFrame.height,\n                areaFrame.bottom,\n                AreaOrientation.HORIZONTAL\n            ),\n            false\n        ];\n\n        if (axis === AreaOrientation.VERTICAL)\n        {\n            this.addChild(area, primaryFirstChild, primarySecondChild);\n        }\n        else\n        {\n            const i = this.getChildren(parent).indexOf(area);\n            primaryFirstChild[0] = parent;\n            primarySecondChild[0] = parent;\n            this.getChildren(parent).splice(i, 1, primaryFirstChild, primarySecondChild);\n        }\n\n        if (holeFrame.width !== areaFrame.height)\n        {\n            const secondaryFirstChild: AreaNode = [\n                primaryFirstChild,\n                Area.makeArea(\n                    areaFrame.left,\n                    areaFrame.x + holeFrame.width,\n                    AreaOrientation.VERTICAL\n                ),\n                true\n            ];\n            const secondarySecondChild: AreaNode = [\n                primaryFirstChild,\n                Area.makeArea(\n                    areaFrame.x + holeFrame.width,\n                    areaFrame.right,\n                    AreaOrientation.VERTICAL\n                ),\n                false\n            ];\n\n            this.addChild(primaryFirstChild, secondaryFirstChild, secondarySecondChild);\n\n            return secondaryFirstChild;\n        }\n        else\n        {\n            (primaryFirstChild as AreaNode)[2] = true;\n        }\n\n        return primaryFirstChild;\n    }\n\n    protected merge(\n        area: AreaNode\n    ) {\n        if (this.hasChildren(area))\n        {\n            throw new Error(\"Cannot merge a non-leaf node\");\n        }\n\n        const parent = this.getParent(area);\n\n        if (!parent)\n        {\n            return;\n        }\n\n        const siblings = this.getChildren(parent);\n        const i = siblings.indexOf(area);\n\n        const leftSibling = siblings[i - 1];\n        const rightSibling = siblings[i + 1];\n\n        if (rightSibling && rightSibling[2] === false)\n        {\n            // Merge rightSibling into area\n            area[1] = Area.setCloseOffset(area[1], Area.getCloseOffset(rightSibling[1]));\n            siblings.splice(i + 1, 1);\n        }\n        if (leftSibling && leftSibling[2] === false)\n        {\n            // Merge leftSibling into area\n            area[1] = Area.setOpenOffset(area[1], Area.getOpenOffset(leftSibling[1]));\n            siblings.splice(i - 1, 1);\n        }\n\n        if (siblings.length === 1) {\n            parent[2] = false;\n            this.merge(parent);\n        }\n    }\n\n    private printState(area: AreaNode): void\n    {\n        if (!this.hasChildren(area)) {\n            console.log({ ...this.getFrame(area) }, area[2])\n        } else {\n            this.getChildren(area).forEach(n => this.printState(n))\n        }\n    }\n}", "/**\n * The orientation of an area indicates the axis along which it is split. This is a 1-bit field.\n *\n * @public\n */\nexport enum AreaOrientation {\n    HORIZONTAL = 0,\n    VERTICAL = 1\n};\n\n/**\n * Alias for the 31-bit field texture-area type.\n *\n * @public\n */\nexport type AreaField = number;\n\n/**\n * An area represents an oriented rectangular region. It is implemented as a 31-bit field. The open/close edges are\n * specified along its parent's orientation axis, i.e. if the parent is horizontal, the left and right edges are defined,\n * else if the parent is vertical, the top and bottom edges are defined. Similarly, the open/close edges of its\n * children will be along its own orientation axis.\n *\n * The orientation axes flip-flop along the hierarchy, i.e. an area's parent's orientation is always opposite to\n * the area's own orientation. This is because if the orientation were to be same, the area's children could be\n * \"pulled up\" to the parent making itself redundant.\n *\n * All four edges of an area can be retrieved from it and its parent.\n *\n * <table>\n *  <thead>\n *    <tr>\n *      <th>Field</th>\n *      <th>Bits</th>\n *      <th>Description</th>\n *    </tr>\n *  </thead>\n *  <tbody>\n *    <tr>\n *      <td>OPEN_OFFSET</td>\n *      <td>0-14</td>\n *      <td>\n *        The offset along the parent's axis at which the area begins. If orientation is horizontal,\n *        this is the left edge. If orientation is vertical, this is the top edge.\n *      </td>\n *    </tr>\n *    <tr>\n *      <td>CLOSE_OFFSET</td>\n *      <td>15-29</td>\n *      <td>\n *        The offset along the parent's axis at which the area ends. If orientation is horizontal,\n *        this is the right edge. If orientation is vertical, this is the bottom edge.\n *      </td>\n *    </tr>\n *    <tr>\n *      <td>ORIENTATION</td>\n *      <td>30</td>\n *      <td>\n *        The orientation of the area, which indicates the axis along it is split. The open and close\n *        offsets of its children are along this axis. See {@link AreaOrientation}.\n *      </td>\n *    </tr>\n *  </tbody>\n * </table>\n *\n * @public\n */\nexport class Area\n{\n    static makeArea(openOffset: number, closeOffset: number, orientation: number): number\n    {\n        return openOffset | (closeOffset << 15) | (orientation << 30);\n    }\n\n    static getOpenOffset(area: AreaField): number\n    {\n        return area & ((1 << 15) - 1);\n    }\n\n    static getCloseOffset(area: AreaField): number\n    {\n        return (area >> 15) & ((1 << 15) - 1);\n    }\n\n    static getOrientation(area: AreaField): AreaOrientation\n    {\n        return (area >> 30) & 1;\n    }\n\n    static setOpenOffset(area: AreaField, offset: number): number\n    {\n        return Area.makeArea(\n            offset,\n            Area.getCloseOffset(area),\n            Area.getOrientation(area)\n        );\n    }\n\n    static setCloseOffset(area: AreaField, offset: number): number\n    {\n        return Area.makeArea(\n            Area.getOpenOffset(offset),\n            offset,\n            Area.getOrientation(area)\n        );\n    }\n}", "import { AtlasSource, optimizeAtlasUploads } from './AtlasSource';\nimport { Texture } from 'pixi.js';\nimport { TextureAllocator } from './TextureAllocator';\n\nimport type { AtlasItemSource, AtlasItem } from './AtlasSource';\nimport type { Renderer } from 'pixi.js';\n\n/**\n * This texture allocator auto-manages the base-texture with an {@link AtlasSource}. You can also\n * pass a texture source to `allocate`, mimicing {@link Texture.from} functionality.\n *\n * @public\n */\nexport class AtlasAllocator extends TextureAllocator<AtlasSource>\n{\n    /**\n     * Creates an atlas allocator.\n     *\n     * @param renderer - The renderer to register the atlas source uploader for. This is optional, but\n     *  the atlas textures won't work without calling {@link optimizeAtlasUploads} on the renderer.\n     * @param slabWidth\n     * @param slabHeight\n     */\n    constructor(renderer: Renderer | null, slabWidth = 2048, slabHeight = 2048) {\n        super(slabWidth, slabHeight);\n\n        if (renderer)\n        {\n            optimizeAtlasUploads(renderer);\n        }\n    }\n\n    /**\n     * Creates a texture slab backed by an {@link AtlasSource}.\n     */\n    protected override createSlabSource(): AtlasSource\n    {\n        return new AtlasSource(this.slabWidth, this.slabHeight);\n    }\n\n    /**\n     * Allocates a texture backed by the given atlas source, with the given padding.\n     *\n     * @override\n     * @param width\n     * @param height\n     * @param padding\n     * @param source\n     */\n    allocate(width: number, height: number, padding?: number, source?: AtlasItemSource): Texture;\n\n    /**\n     * Allocates a texture backed by the given source, with default padding.\n     *\n     * @param width\n     * @param height\n     * @param source\n     */\n    allocate(width: number, height: number, source?: AtlasItemSource): Texture;\n\n    allocate(width: number, height: number, paddingOrSource?: number | AtlasItemSource, source?: AtlasItemSource): Texture\n    {\n        let padding: number;\n\n        if (typeof paddingOrSource === 'number')\n        {\n            padding = paddingOrSource;\n        }\n        else\n        {\n            padding = this.calculatePadding(width, height);\n            source = paddingOrSource;\n        }\n\n        const texture = super.allocate(width, height, padding);\n\n        if (source)\n        {\n            const atlas = texture.source as AtlasSource;\n            const item = {\n                frame: texture.frame,\n                source,\n                // dirtyId !== updateId only if image loaded\n                dirtyId: source instanceof HTMLImageElement && !source.complete ? -1 : 0,\n                updateId: -1,\n                texture,\n            } satisfies AtlasItem;\n\n            atlas.managedItems.push(item);\n\n            if (source instanceof HTMLImageElement && !source.complete)\n            {\n                source.addEventListener('load', () =>\n                {\n                    if (!texture.source.destroyed && atlas.managedItems.indexOf(item) >= 0)\n                    {\n                        item.dirtyId++;\n                        atlas.update();\n                        texture.update();\n                    }\n                    else\n                    {\n                        console.warn('Image loaded after texture was destroyed');\n                    }\n                });\n            }\n\n            atlas.update();\n        }\n\n        return texture;\n    }\n\n    free(texture: Texture): void\n    {\n        super.free(texture);\n\n        const atlas = texture.source as AtlasSource;\n        const item = atlas.managedItems.find((item) => item.texture === texture);\n\n        if (item)\n        {\n            atlas.managedItems.splice(atlas.managedItems.indexOf(item), 1);\n        }\n    }\n}", "import { CanvasSource } from 'pixi.js';\nimport { TextureAllocator } from './TextureAllocator';\n\n/**\n * This allocator issues texture backed by a canvas. You can draw on to that canvas to source\n * each texture.\n *\n * @public\n */\nexport class CanvasTextureAllocator extends TextureAllocator<CanvasSource>\n{\n    /**\n     * Creates a texture slab backed by a canvas.\n     */\n    protected override createSlabSource(): CanvasSource\n    {\n        return new CanvasSource({\n            height: this.slabHeight,\n            width: this.slabWidth,\n        });\n    }\n}", "import { RenderTexture, TextureSource } from 'pixi.js';\nimport { TextureAllocator } from './TextureAllocator';\n\nimport type { Rectangle } from 'pixi.js';\n\n/**\n * This allocator issues render-textures, and is otherwise just like {@link TextureAllocator}.\n *\n * @public\n */\nexport class RenderTextureAllocator extends TextureAllocator<TextureSource, RenderTexture>\n{\n    /**\n     * Creates a texture slab backed by a base render-texture.\n     */\n    protected override createSlabSource(): TextureSource\n    {\n        return new TextureSource({\n            height: this.slabHeight,\n            width: this.slabWidth,\n        });\n    }\n\n    /**\n     * Creates a render-texture from the given base render-texture.\n     *\n     * @param source\n     * @param frame\n     */\n    protected override createTexture(source: TextureSource, frame: Rectangle): RenderTexture\n    {\n        return new RenderTexture({\n            frame,\n            source,\n        });\n    }\n}"],
  "mappings": "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",
  "names": ["import_pixi", "import_pixi", "SPLIT_ORIENTATION", "tempRect", "slab", "item", "import_pixi", "import_pixi"]
}
