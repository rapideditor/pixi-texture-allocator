{
  "version": 3,
  "sources": ["../src/index.ts", "../src/Area.ts", "../src/AtlasResource.ts", "../src/AtlasAllocator.ts", "../src/GuilloteneAllocator.ts", "../src/TextureAllocator.ts", "../src/CanvasTextureAllocator.ts", "../src/RenderTextureAllocator.ts"],
  "sourcesContent": ["export * from './Area';\nexport * from './AreaAllocator';\nexport * from './AtlasAllocator';\nexport * from './AtlasResource';\nexport * from './CanvasTextureAllocator';\nexport * from './GuilloteneAllocator';\nexport * from './RenderTextureAllocator';\nexport * from './TextureAllocator';\nexport * from './TextureSlab';", "/**\n * The orientation of an area indicates the axis along which it is split. This is a 1-bit field.\n *\n * @public\n */\nexport enum AreaOrientation {\n    HORIZONTAL = 0,\n    VERTICAL = 1\n};\n\n/**\n * Alias for the 31-bit field texture-area type.\n *\n * @public\n */\nexport type AreaField = number;\n\n/**\n * An area represents an oriented rectangular region. It is implemented as a 31-bit field. The open/close edges are\n * specified along its parent's orientation axis, i.e. if the parent is horizontal, the left and right edges are defined,\n * else if the parent is vertical, the top and bottom edges are defined. Similarly, the open/close edges of its\n * children will be along its own orientation axis.\n *\n * The orientation axes flip-flop along the hierarchy, i.e. an area's parent's orientation is always opposite to\n * the area's own orientation. This is because if the orientation were to be same, the area's children could be\n * \"pulled up\" to the parent making itself redundant.\n *\n * All four edges of an area can be retrieved from it and its parent.\n *\n * <table>\n *  <thead>\n *    <tr>\n *      <th>Field</th>\n *      <th>Bits</th>\n *      <th>Description</th>\n *    </tr>\n *  </thead>\n *  <tbody>\n *    <tr>\n *      <td>OPEN_OFFSET</td>\n *      <td>0-14</td>\n *      <td>\n *        The offset along the parent's axis at which the area begins. If orientation is horizontal,\n *        this is the left edge. If orientation is vertical, this is the top edge.\n *      </td>\n *    </tr>\n *    <tr>\n *      <td>CLOSE_OFFSET</td>\n *      <td>15-29</td>\n *      <td>\n *        The offset along the parent's axis at which the area ends. If orientation is horizontal,\n *        this is the right edge. If orientation is vertical, this is the bottom edge.\n *      </td>\n *    </tr>\n *    <tr>\n *      <td>ORIENTATION</td>\n *      <td>30</td>\n *      <td>\n *        The orientation of the area, which indicates the axis along it is split. The open and close\n *        offsets of its children are along this axis. See {@link AreaOrientation}.\n *      </td>\n *    </tr>\n *  </tbody>\n * </table>\n *\n * @public\n */\nexport class Area\n{\n    static makeArea(openOffset: number, closeOffset: number, orientation: number): number\n    {\n        return openOffset | (closeOffset << 15) | (orientation << 30);\n    }\n\n    static getOpenOffset(area: AreaField): number\n    {\n        return area & ((1 << 15) - 1);\n    }\n\n    static getCloseOffset(area: AreaField): number\n    {\n        return (area >> 15) & ((1 << 15) - 1);\n    }\n\n    static getOrientation(area: AreaField): AreaOrientation\n    {\n        return (area >> 30) & 1;\n    }\n\n    static setOpenOffset(area: AreaField, offset: number): number\n    {\n        return Area.makeArea(\n            offset,\n            Area.getCloseOffset(area),\n            Area.getOrientation(area)\n        );\n    }\n\n    static setCloseOffset(area: AreaField, offset: number): number\n    {\n        return Area.makeArea(\n            Area.getOpenOffset(offset),\n            offset,\n            Area.getOrientation(area)\n        );\n    }\n}", "import { ALPHA_MODES } from '@pixi/constants';\nimport { BaseTexture, GLTexture, Resource, Renderer } from '@pixi/core';\n\nimport type { Rectangle } from '@pixi/math';\nimport type { Texture } from '@pixi/core';\n\n/**\n * Types of image sources supported by {@link AtlasResource}.\n *\n * @public\n */\nexport type AtlasResourceSource =  HTMLImageElement | HTMLCanvasElement | ImageBitmap | ImageData | ArrayBufferView;\n\n/**\n * An item that is uploaded to the atlas texture.\n *\n * @public\n */\nexport type AtlasResourceItem =\n{\n    /**\n     * The location of the atlas item in the base-texture's space.\n     */\n    frame: Rectangle;\n\n    /**\n     * The source of the texture data.\n     */\n    source: AtlasResourceSource;\n\n    /**\n     * This flags when the resource is to be re-uploaded.\n     */\n    dirtyId: number;\n\n    /**\n     * This flags when the resource is uploaded and update-to-date with the dirty ID.\n     */\n    updateId: number;\n\n    /**\n     * The texture holding this item.\n     */\n    texture: Texture;\n};\n\n/**\n * An {@code AtlasResource} is used by {@link AtlasAllocator} to manage texture sources\n *\n * @public\n */\nexport class AtlasResource extends Resource\n{\n    /**\n     * The list of managed resources in the atlas.\n     */\n    public managedItems: AtlasResourceItem[];\n\n    /**\n     * Creates an atlas resource.\n     *\n     * @param width\n     * @param height\n     */\n    constructor(width: number, height: number)\n    {\n        super(width, height);\n\n        this.managedItems = [];\n    }\n\n    /**\n     * Uploads the atlas.\n     *\n     * @param renderer\n     * @param baseTexture\n     * @param glTexture\n     */\n    upload(renderer: Renderer, baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        const gl: WebGLRenderingContext = renderer.gl;\n        const width = baseTexture.realWidth;\n        const height = baseTexture.realHeight;\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK)\n\n        // Allocate the texture on the GPU\n        if (glTexture.width !== width ||\n            glTexture.height !== height)\n        {\n            glTexture.width = width;\n            glTexture.height = height;\n\n            gl.texImage2D(\n                baseTexture.target,\n                0,\n                baseTexture.format,\n                width,\n                height,\n                0,\n                baseTexture.format,\n                baseTexture.type,\n                undefined\n            );\n        }\n\n        const items = this.managedItems;\n\n        // Upload all atlas items.\n        for (let i = 0, j = items.length; i < j; i++)\n        {\n            this.uploadItem(\n                renderer,\n                baseTexture.target,\n                baseTexture.format,\n                baseTexture.type,\n                items[i]\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Uploads the atlas item to the GPU.\n     *\n     * @param renderer - The renderer holding the WebGL context.\n     * @param target - The binding point of the base-texture.\n     * @param format - The format of the base-texture.\n     * @param type - The type of the base-texture data.\n     * @param item - The item to upload.\n     */\n    protected uploadItem(\n        renderer: Renderer,\n        target: number,\n        format: number,\n        type: number,\n        item: AtlasResourceItem\n    ): void\n    {\n        if (item.updateId === item.dirtyId)\n        {\n            return;\n        }\n\n        const gl: WebGLRenderingContext = renderer.gl;\n        const source = item.source;\n        const frame = item.frame;\n\n        gl.texSubImage2D(\n            target,\n            0,\n            frame.x,\n            frame.y,\n            frame.width,\n            frame.height,\n            format,\n            type,\n            source as any,\n        );\n\n        item.updateId = item.dirtyId;\n    }\n}", "import { AtlasResource } from './AtlasResource';\nimport { BaseTexture, Texture } from '@pixi/core';\nimport { GuilloteneAllocator } from './GuilloteneAllocator';\nimport { TextureAllocator } from './TextureAllocator';\nimport { TextureSlab } from './TextureSlab';\n\nimport type { AtlasResourceSource } from './AtlasResource';\n\n/**\n * This texture allocator auto-manages the base-texture with an {@link AtlasResource}. You can also\n * pass a texture source to `allocate`, mimicing {@link Texture.from} functionality.\n *\n * @public\n */\nexport class AtlasAllocator extends TextureAllocator\n{\n    /**\n     * Creates a texture slab backed by an {@link AtlasResource}.\n     */\n    protected createSlab(): TextureSlab\n    {\n        return {\n            managedArea: new GuilloteneAllocator(this.slabWidth, this.slabHeight),\n            managedTextures: [],\n            slab: new BaseTexture(new AtlasResource(this.slabWidth, this.slabHeight),\n            {\n                width: this.slabWidth,\n                height: this.slabHeight,\n            }),\n        };\n    }\n\n    /**\n     * Allocates a texture backed by the given atlas source, with the given padding.\n     *\n     * @override\n     * @param width\n     * @param height\n     * @param padding\n     * @param source\n     */\n    allocate(width: number, height: number, padding?: number, source?: AtlasResourceSource): Texture;\n\n    /**\n     * Allocates a texture backed by the given source, with default padding.\n     *\n     * @param width\n     * @param height\n     * @param source\n     */\n    allocate(width: number, height: number, source?: AtlasResourceSource): Texture;\n\n    allocate(width: number, height: number, paddingOrSource?: number | AtlasResourceSource, source?: AtlasResourceSource): Texture\n    {\n        let padding: number;\n\n        if (typeof paddingOrSource === 'number')\n        {\n            padding = paddingOrSource;\n        }\n        else\n        {\n            padding = this.calculatePadding(width, height);\n            source = paddingOrSource;\n        }\n\n        const texture = super.allocate(width, height, padding);\n\n        if (source)\n        {\n            const atlas = texture.baseTexture.resource as AtlasResource;\n            const item = {\n                frame: texture.frame,\n                source,\n                // dirtyId !== updateId only if image loaded\n                dirtyId: source instanceof HTMLImageElement && !source.complete ? -1 : 0,\n                updateId: -1,\n                texture,\n            };\n\n            atlas.managedItems.push(item);\n\n            if (source instanceof HTMLImageElement && !source.complete) {\n                source.addEventListener('load', () => {\n                    if (texture.baseTexture.valid && !texture.baseTexture.destroyed && atlas.managedItems.indexOf(item) >= 0) {\n                        item.dirtyId++;\n                        texture.baseTexture.update();\n                    }\n                });\n            }\n\n            texture.baseTexture.update();\n        }\n\n        return texture;\n    }\n\n    free(texture: Texture): void\n    {\n        super.free(texture);\n\n        const atlas = texture.baseTexture.resource as AtlasResource;\n        const item = atlas.managedItems.find(item => item.texture === texture);\n\n        if (item)\n        {\n            atlas.managedItems.splice(atlas.managedItems.indexOf(item), 1);\n        }\n    }\n}", "import { Rectangle } from '@pixi/math';\nimport { Area, AreaOrientation } from './Area';\n\nimport type { AreaAllocator } from './AreaAllocator';\nimport type { AreaField } from './Area';\n\n/**\n * An allocator node is represented as a tuple. The zeroth element is the parent of the node. The first element\n * always exists and is the texture area it wholly represents. The second element is whether the rectangle\n * is allocated or free. The last element is optional and is the list\n * of its children.\n *\n * @public\n * @ignore\n */\nexport type AreaNode = [AreaNode, AreaField, boolean] | [AreaNode, AreaField, AreaNode[]];\n\n/**\n * Pointer to guillotene node.\n *\n * @public\n * @ignore\n */\nexport type AreaPtr = { __mem_area: AreaNode };\n\n/**\n * @public\n * @ignore\n */\nexport enum SPLIT_ORIENTATION {\n    HOR = 0,\n    VERT = 1,\n    NONE = 2\n}\n\nconst tempRect = new Rectangle();\n\n/** @public */\nexport class GuilloteneAllocator implements AreaAllocator<AreaPtr>\n{\n    protected _root: AreaNode;\n\n    private _width: number;\n    private _height: number;\n\n    constructor(width: number, height: number)\n    {\n        this._width = width;\n        this._height = height;\n\n        // NOTE: getFrame assumes root node is always horizontal!\n        this._root = [\n            null,\n            Area.makeArea(0, this._height, AreaOrientation.HORIZONTAL),\n            false\n        ];\n    }\n\n    /**\n     * Allocates an area of the given `width` and `height`.\n     *\n     * @param width - The width required for the allocated area.\n     * @param height - The height required for the allocated area.\n     * @param rect - An optional `Rectangle` instance to put the resulting area frame into.\n     * @return The rectangle frame of the area allocated.\n     */\n    allocate(width: number, height: number, rect?: Rectangle): Rectangle & AreaPtr\n    {\n        const area = this.findArea(width, height);\n\n        if (!area)\n        {\n            return null;\n        }\n\n        if (!rect)\n        {\n            rect = new Rectangle();\n        }\n\n        this.getFrame(area, rect);\n\n        const hole = new Rectangle(rect.x, rect.y, width, height);\n        const node = this.split(area, rect, hole);\n\n        rect.copyFrom(hole);\n        (rect as any).__mem_area = node;\n\n        return rect as (Rectangle & AreaPtr);\n    }\n\n    /**\n     * Frees the area represented by the given area pointer. The original rectangle returned by\n     * {@link GuilloteneAllocator#allocate} included this pointer (the `__mem_area` property).\n     *\n     * @param areaPtr\n     */\n    free(areaPtr: AreaPtr): void\n    {\n        const area = areaPtr.__mem_area;\n\n        area[2] = false;\n        this.merge(area);\n    }\n\n    get width(): number\n    {\n        return this._width;\n    }\n\n    get height(): number\n    {\n        return this._height;\n    }\n\n    /**\n     * Returns the [area]{@link Area} data for the node.\n     *\n     * @param node\n     * @returns The area data for the node.\n     */\n    protected getAreaField(node: AreaNode): AreaField\n    {\n        return node[1];\n    }\n\n    /**\n     * Returns the rectangle covered by the area node.\n     *\n     * @param node - The node whose covered rectangular area is needed.\n     * @param rect - An optional `Rectangle` instance to put the data in.\n     * @return The rectangle covered by `node`.\n     */\n    protected getFrame(node: AreaNode, rect?: Rectangle): Rectangle\n    {\n        if (!rect)\n        {\n            rect = new Rectangle();\n        }\n\n        const nodeArea = this.getAreaField(node);\n        const nodeParent = this.getParent(node);\n        const nodeOrientation = Area.getOrientation(nodeArea);\n        const nodeOpen = Area.getOpenOffset(nodeArea);\n        const nodeClose = Area.getCloseOffset(nodeArea);\n        const parentOpen = nodeParent ? Area.getOpenOffset(nodeParent[1]) : 0;\n        const parentClose = nodeParent ? Area.getCloseOffset(nodeParent[1]) : this._width;// (because root node is horizontal)\n\n        if (nodeOrientation) // VERTICAL\n        {\n            rect.x = nodeOpen;\n            rect.y = parentOpen;\n            rect.width = nodeClose - rect.x;\n            rect.height = parentClose - parentOpen;\n        }\n        else // HORIZONTAL\n        {\n            rect.x = parentOpen;\n            rect.y = nodeOpen;\n            rect.width = parentClose - rect.x;\n            rect.height = nodeClose - rect.y;\n        }\n\n        return rect;\n    }\n\n    /**\n     * Returns the parent of the area node.\n     *\n     * @param node\n     * @return The parent of `node`\n     */\n    protected getParent(node: AreaNode): AreaNode\n    {\n        return node[0];\n    }\n\n    /**\n     * Returns whether the given node has any children.\n     *\n     * @param node\n     * @return Whether the given node has any children.\n     */\n    protected hasChildren(node: AreaNode): boolean\n    {\n        return (Array.isArray(node[2]) && (node[2].length !== 0));\n    }\n\n    /**\n     * Returns the children of the passed node, if any.\n     *\n     * @param node\n     */\n    protected getChildren(node: AreaNode): AreaNode[]\n    {\n        if (!Array.isArray(node[2])) {\n            throw new Error(\"Children don't exist\")\n        }\n\n        return node[2];\n    }\n\n    protected addChild(parent: AreaNode, ...nodes: AreaNode[]): void\n    {\n        parent[2] = Array.isArray(parent[2]) ? parent[2] : []\n        parent[2].push(...nodes)\n    }\n\n    /**\n     * Finds an area node with minimum width `aw` and minimum height `ah`.\n     *\n     * @param aw\n     * @param ah\n     */\n    protected findArea(aw: number, ah: number): AreaNode\n    {\n        return this.findAreaRecursive(this._root, aw, ah);\n    }\n\n    /**\n     * The recursive implementation for {@link AreaAllocator#findArea}.\n     *\n     * @param rootArea\n     * @param aw\n     * @param ah\n     */\n    protected findAreaRecursive(rootArea: AreaNode, aw: number, ah: number): AreaNode\n    {\n        const frame = this.getFrame(rootArea, tempRect);\n\n        if (frame.width < aw || frame.height < ah)\n        {\n            return null;\n        }\n\n        if (!this.hasChildren(rootArea))\n        {\n            const dx = frame.width - aw;\n            const dy = frame.height - ah;\n\n            if (dx < 0 || dy < 0 || rootArea[2])\n            {\n                return null;\n            }\n\n            return rootArea;\n        }\n\n        const children = this.getChildren(rootArea);\n\n        let bestCandidate = null;\n        let bestCandidateScore = Infinity;\n\n        for (let i = 0, j = children.length; i < j; i++)\n        {\n            const candidate = this.findAreaRecursive(children[i], aw, ah);\n\n            if (!candidate)\n            {\n                continue;\n            }\n\n            const candidateFrame = this.getFrame(candidate, tempRect);\n\n            const dx = candidateFrame.width - aw;\n            const dy = candidateFrame.height - ah;\n\n            if (dx < 0 || dy < 0)\n            {\n                continue;\n            }\n            if (!dx && !dy)\n            {\n                // Perfect fit!\n                return candidate;\n            }\n\n            const score = Math.min(dx, dy);\n\n            if (bestCandidateScore > score)\n            {\n                bestCandidate = candidate;\n                bestCandidateScore = score;\n            }\n        }\n\n        return bestCandidate;\n    }\n\n    /**\n     * Returns the orientation of the primary split of host.\n     */\n    protected splitOrientation(host: Rectangle, hole: Rectangle): SPLIT_ORIENTATION\n    {\n        if (hole.width === host.width && hole.height === host.height) {\n            return SPLIT_ORIENTATION.NONE;\n        }\n        if (hole.width === host.width) {\n            return SPLIT_ORIENTATION.VERT;\n        }\n        if (hole.height === host.height) {\n            return SPLIT_ORIENTATION.HOR;\n        }\n\n        // ____________________\n        // |        |         |\n        // |        |         |\n        // |  hole  |         |\n        // |        |         |\n        // |________| Primary |\n        // |        |         |\n        // |        |         |\n        // |  Sec.  |         |\n        // |________|_________|\n        const horAreaDiff = Math.abs(\n            // (Primary) Right\n            (host.width - hole.width) * host.height -\n            // (Secondary) Bottom\n            hole.width * (host.height - hole.height)\n        )\n\n        // ____________________\n        // |        |         |\n        // |        |         |\n        // |  hole  | Sec.    |\n        // |        |         |\n        // |________|_________|\n        // |                  |\n        // |    Primary       |\n        // |__________________|\n        const verAreaDiff = Math.abs(\n            // (Primary) Bottom\n            host.width * (host.height - hole.height) -\n            (host.width - hole.width) * hole.height\n        )\n\n        if (horAreaDiff > verAreaDiff)\n        {\n            return SPLIT_ORIENTATION.HOR\n        }\n        else\n        {\n            return SPLIT_ORIENTATION.VERT\n        }\n    }\n\n    protected split(\n        area: AreaNode,\n        areaFrame: Rectangle,\n        holeFrame: Rectangle,\n        orientation: SPLIT_ORIENTATION = this.getParent(area) ? this.splitOrientation(areaFrame, holeFrame) : SPLIT_ORIENTATION.HOR\n    ): AreaNode\n    {\n        if (area[2] === true)\n        {\n            throw new Error('Cannot deallocate')\n        }\n        if (orientation === SPLIT_ORIENTATION.NONE)\n        {\n            area[2] = true;\n            return area;\n        }\n\n        return this[orientation === SPLIT_ORIENTATION.HOR\n            ? 'splitPrimaryHorizontal'\n            : 'splitPrimaryVertical'](area, areaFrame, holeFrame);\n    }\n\n    private splitPrimaryHorizontal(area: AreaNode, areaFrame: Rectangle, holeFrame: Rectangle): AreaNode\n    {\n        const field = this.getAreaField(area);\n        const axis = Area.getOrientation(field);\n        const parent = this.getParent(area);\n\n        if (this.hasChildren(area))\n        {\n            throw new Error(\"Can't split non-leaf node\")\n        }\n\n        const firstChild: AreaNode = [\n            area,\n            Area.makeArea(\n                areaFrame.left,\n                areaFrame.x + holeFrame.width,\n                AreaOrientation.VERTICAL\n            ),\n            []\n        ];\n        const secondChild: AreaNode = [\n            area,\n            Area.makeArea(\n                areaFrame.x + holeFrame.width,\n                areaFrame.right,\n                AreaOrientation.VERTICAL\n            ),\n            false\n        ];\n\n        if (axis === AreaOrientation.HORIZONTAL) {\n            this.addChild(area, firstChild, secondChild)\n        } else {\n            const i = this.getChildren(parent).indexOf(area);\n\n            firstChild[0] = parent;\n            secondChild[0] = parent;\n\n            this.getChildren(parent).splice(i, 1, firstChild, secondChild);\n        }\n\n        if (holeFrame.height !== areaFrame.height)\n        {\n            const secondaryFirstChild: AreaNode = [\n                firstChild,\n                Area.makeArea(\n                    areaFrame.top,\n                    areaFrame.y + holeFrame.height,\n                    AreaOrientation.HORIZONTAL\n                ),\n                true\n            ];\n            const secondarySecondChild: AreaNode = [\n                firstChild,\n                Area.makeArea(\n                    areaFrame.y + holeFrame.height,\n                    areaFrame.bottom,\n                    AreaOrientation.HORIZONTAL\n                ),\n                false\n            ];\n\n            this.addChild(firstChild, secondaryFirstChild, secondarySecondChild);\n\n            return secondaryFirstChild;\n        }\n        else\n        {\n            (firstChild as AreaNode)[2] = true;\n        }\n\n        return firstChild;\n    }\n\n    private splitPrimaryVertical(area: AreaNode, areaFrame: Rectangle, holeFrame: Rectangle): AreaNode\n    {\n        const field = this.getAreaField(area);\n        const axis = Area.getOrientation(field);\n        const parent = this.getParent(area);\n\n        if (this.hasChildren(area)) {\n            throw new Error(\"Can't split non-leaf node\")\n        }\n\n        const primaryFirstChild: AreaNode = [\n            area,\n            Area.makeArea(\n                areaFrame.top,\n                areaFrame.y + holeFrame.height,\n                AreaOrientation.HORIZONTAL\n            ),\n            []\n        ];\n        const primarySecondChild: AreaNode = [\n            area,\n            Area.makeArea(\n                areaFrame.y + holeFrame.height,\n                areaFrame.bottom,\n                AreaOrientation.HORIZONTAL\n            ),\n            false\n        ];\n\n        if (axis === AreaOrientation.VERTICAL)\n        {\n            this.addChild(area, primaryFirstChild, primarySecondChild);\n        }\n        else\n        {\n            const i = this.getChildren(parent).indexOf(area);\n            primaryFirstChild[0] = parent;\n            primarySecondChild[0] = parent;\n            this.getChildren(parent).splice(i, 1, primaryFirstChild, primarySecondChild);\n        }\n\n        if (holeFrame.width !== areaFrame.height)\n        {\n            const secondaryFirstChild: AreaNode = [\n                primaryFirstChild,\n                Area.makeArea(\n                    areaFrame.left,\n                    areaFrame.x + holeFrame.width,\n                    AreaOrientation.VERTICAL\n                ),\n                true\n            ];\n            const secondarySecondChild: AreaNode = [\n                primaryFirstChild,\n                Area.makeArea(\n                    areaFrame.x + holeFrame.width,\n                    areaFrame.right,\n                    AreaOrientation.VERTICAL\n                ),\n                false\n            ];\n\n            this.addChild(primaryFirstChild, secondaryFirstChild, secondarySecondChild);\n\n            return secondaryFirstChild;\n        }\n        else\n        {\n            (primaryFirstChild as AreaNode)[2] = true;\n        }\n\n        return primaryFirstChild;\n    }\n\n    protected merge(\n        area: AreaNode\n    ) {\n        if (this.hasChildren(area))\n        {\n            throw new Error(\"Cannot merge a non-leaf node\");\n        }\n\n        const parent = this.getParent(area);\n\n        if (!parent)\n        {\n            return;\n        }\n\n        const siblings = this.getChildren(parent);\n        const i = siblings.indexOf(area);\n\n        const leftSibling = siblings[i - 1];\n        const rightSibling = siblings[i + 1];\n\n        if (rightSibling && rightSibling[2] === false)\n        {\n            // Merge rightSibling into area\n            area[1] = Area.setCloseOffset(area[1], Area.getCloseOffset(rightSibling[1]));\n            siblings.splice(i + 1, 1);\n        }\n        if (leftSibling && leftSibling[2] === false)\n        {\n            // Merge leftSibling into area\n            area[1] = Area.setOpenOffset(area[1], Area.getOpenOffset(leftSibling[1]));\n            siblings.splice(i - 1, 1);\n        }\n\n        if (siblings.length === 1) {\n            parent[2] = false;\n            this.merge(parent);\n        }\n    }\n\n    private printState(area: AreaNode): void\n    {\n        if (!this.hasChildren(area)) {\n            console.log({ ...this.getFrame(area) }, area[2])\n        } else {\n            this.getChildren(area).forEach(n => this.printState(n))\n        }\n    }\n}", "import { BaseTexture, Texture } from '@pixi/core';\nimport { GuilloteneAllocator } from './GuilloteneAllocator';\nimport { Rectangle } from '@pixi/math';\n\nimport type { TextureSlab } from './TextureSlab';\n\nconst tempRect = new Rectangle();\n\n/**\n * The texture allocator dynamically manages space on base-texture slabs. It can be used to generate\n * atlases on demand, which improve batching efficiency.\n *\n * @public\n */\nexport class TextureAllocator<T extends Texture = Texture>\n{\n    /**\n     * The width of texture slabs.\n     */\n    public readonly slabWidth: number;\n\n    /**\n     * The height of texture slabs.\n     */\n    public readonly slabHeight: number;\n\n    /**\n     * The list of base-textures that are used to allocate texture space.\n     */\n    protected textureSlabs: TextureSlab[];\n\n    /**\n     * @param slabWidth - The width of base-texture slabs. This should be at most 2048.\n     * @param slabHeight - The height of base-texture slabs. This should be at most 2048.\n     */\n    constructor(slabWidth = 2048, slabHeight = 2048)\n    {\n        this.slabWidth = slabWidth;\n        this.slabHeight = slabHeight;\n\n        this.textureSlabs = [];\n    }\n\n    get maxWidth() {\n        return this.slabWidth - (2 * this.calculatePadding(this.slabWidth, this.slabHeight));\n    }\n\n    get maxHeight() {\n        return this.slabHeight - (2 * this.calculatePadding(this.slabWidth, this.slabHeight));\n    }\n\n    /**\n     * Allocates a texture from this allocator.\n     *\n     * If its existing slab pool has enough space, the texture is issued from one. Otherwise,\n     * a new slab is created and the texture is issued from it. However, if the requested\n     * dimensions are larger than slabs themselves, then `null` is always returned.\n     *\n     * To upload a texture source, you will have to create an atlas-managing {@link Resource}\n     * yourself on the base-texture. The {@link AtlasAllocator} does this for you, while the\n     * {@link CanvasTextureAllocator} can be used to draw on a canvas-based atlas.\n     *\n     * @param width - The width of the requested texture.\n     * @param height - The height of the requested texture.\n     * @param padding - The padding requested around the texture, to prevent bleeding.\n     * @return The allocated texture, if successful; otherwise, `null`.\n     */\n    allocate(width: number, height: number, padding = this.calculatePadding(width, height)): T\n    {\n        // Cannot allocate a texture larger than a texture-slab.\n        if (width + 2 * padding > this.slabWidth ||\n                height + 2 * padding > this.slabHeight)\n        {\n            return null;\n        }\n\n        const slabs = this.textureSlabs;\n\n        // Loop through the slabs and find one with enough space, if any.\n        for (let i = 0, j = slabs.length; i < j; i++)\n        {\n            const slab = slabs[i];\n            const texture = this.issueTexture(slab, width, height, padding);\n\n            if (texture)\n            {\n                return texture;\n            }\n        }\n\n        // Issue a new slab.\n        const slab = this.createSlab();\n\n        // Append this slab to the head of the list.\n        this.textureSlabs.unshift(slab);\n\n        // Issue the texture from this blank slab.\n        return this.issueTexture(slab, width, height, padding);\n    }\n\n    /**\n     * Frees the texture and reclaims its space. It is assumed you will not use it again, and have\n     * destroyed any resource uploading its data.\n     *\n     * @param texture\n     * @throws When the texture was not located in this allocator.\n     */\n    free(texture: T): void\n    {\n        const baseTexture = (texture as Texture).baseTexture;\n        const slab = this.textureSlabs.find(sl => sl.slab === baseTexture);\n\n        if (!slab)\n        {\n            throw new Error(\"The texture cannot be freed because \" +\n                \"its base-texture is not pooled by this allocator. \" +\n                \"This is either a bug in TextureAllocator or you tried to free a \" +\n                \"texture that was never allocated by one.\");\n        }\n\n        const textureEntry = slab.managedTextures.find(entry => entry.texture === texture);\n\n        if (!textureEntry)\n        {\n            throw new Error(\"The texture cannot be freed because it was not found \" +\n                \"in the managed list of issued textures on its slab. This may be because you \" +\n                \"duplicated this texture or a bug in TextureAllocator\");\n        }\n\n        slab.managedArea.free(textureEntry.area);\n        slab.managedTextures.splice(slab.managedTextures.indexOf(textureEntry), 1);\n    }\n\n    protected calculatePadding(width: number, height: number): number\n    {\n        const dimen = Math.max(width, height);\n\n        if (dimen < 64)\n        {\n            return 2;\n        }\n        else if (dimen < 128)\n        {\n            return 4;\n        }\n        else if (dimen < 1024)\n        {\n            return 8;\n        }\n        else\n        {\n            return 16;\n        }\n    }\n\n    /**\n     * Creates a texture slab. The slab's base-texture is not backed by any resource. You\n     * will have to manage that yourself. See {@link AtlasAllocator} or {@link CanvasTextureAllocator}\n     * for better resource semantics.\n     */\n    protected createSlab(): TextureSlab\n    {\n        return {\n            managedArea: new GuilloteneAllocator(this.slabWidth, this.slabHeight),\n            managedTextures: [],\n            slab: new BaseTexture(null,\n            {\n                width: this.slabWidth,\n                height: this.slabHeight,\n            }),\n        };\n    }\n\n    /**\n     * Creates a texture on the given base-texture at {@code frame}.\n     *\n     * @param baseTexture - The base texture that will hold the texture's space.\n     * @param frame - The frame in which the texture will be stored.\n     */\n    protected createTexture(baseTexture: BaseTexture, frame: Rectangle): T\n    {\n        // Override this method to return correct texture type T.\n        return new Texture(baseTexture, frame) as T;\n    }\n\n    /**\n     * Issues a texture from the given texture slab, if possible.\n     *\n     * @param slab - The texture slab to allocate frame.\n     * @param width - The width of the requested texture.\n     * @param height - The height of the requested texture.\n     * @param padding - Padding required around the texture.\n     * @return The issued texture, if successful; otherwise, `null`.\n     */\n    protected issueTexture(slab: TextureSlab, width: number, height: number, padding = 0): T\n    {\n        const area = slab.managedArea.allocate(width + 2 * padding, height + 2 * padding);\n\n        if (!area)\n        {\n            return null;\n        }\n\n        tempRect.copyFrom(area);\n        tempRect.pad(-padding);\n\n        const baseTexture = slab.slab;\n        const issuedTexture = this.createTexture(baseTexture, tempRect.clone());\n\n        slab.managedTextures.push({\n            area,\n            texture: issuedTexture,\n        });\n\n        return issuedTexture;\n    }\n}", "import { BaseTexture } from '@pixi/core';\n\nimport { GuilloteneAllocator } from './GuilloteneAllocator';\nimport { TextureAllocator } from './TextureAllocator';\nimport { TextureSlab } from './TextureSlab';\n\n/**\n * This allocator issues texture backed by a canvas. You can draw on to that canvas to soruce\n * each texture.\n *\n * @public\n */\nexport class CanvasTextureAllocator extends TextureAllocator\n{\n    /**\n     * Creates a texture slab backed by a canvas.\n     */\n    protected createSlab(): TextureSlab\n    {\n        const canvas = document.createElement('canvas');\n\n        canvas.width = this.slabWidth;\n        canvas.height = this.slabHeight;\n\n        return {\n            managedArea: new GuilloteneAllocator(this.slabWidth, this.slabHeight),\n            managedTextures: [],\n            slab: new BaseTexture(canvas, {\n                width: this.slabWidth,\n                height: this.slabHeight\n            })\n        };\n    }\n}", "import { BaseRenderTexture, RenderTexture } from '@pixi/core';\nimport { GuilloteneAllocator } from './GuilloteneAllocator';\nimport { TextureAllocator } from './TextureAllocator';\n\nimport type { BaseTexture } from '@pixi/core';\nimport type { Rectangle } from '@pixi/math';\nimport type { TextureSlab } from './TextureSlab';\n\n/**\n * This allocator issues render-textures, and is otherwise just like {@link TextureAllocator}.\n *\n * @public\n */\nexport class RenderTextureAllocator extends TextureAllocator<RenderTexture>\n{\n    /**\n     * Creates a texture slab backed by a base render-texture.\n     */\n    protected createSlab(): TextureSlab\n    {\n        return {\n            managedArea: new GuilloteneAllocator(this.slabWidth, this.slabHeight),\n            managedTextures: [],\n            slab: new BaseRenderTexture({\n                width: this.slabWidth,\n                height: this.slabHeight\n            })\n        };\n    }\n\n    /**\n     * Creates a render-texture from the given base render-texture.\n     *\n     * @param baseTexture\n     * @param frame\n     */\n    protected createTexture(baseTexture: BaseTexture, frame: Rectangle): RenderTexture\n    {\n        return new RenderTexture(baseTexture as BaseRenderTexture, frame);\n    }\n}"],
  "mappings": "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",
  "names": ["AreaOrientation", "import_core", "SPLIT_ORIENTATION", "import_core", "import_math", "tempRect", "slab", "item", "import_core", "import_core"]
}
